# -*- coding: utf-8 -*-
"""ToyGeneticAlgorithm_Student.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ygDAGFBWhBYeTI1FEOi7Yd4tDDX_oUjq

# Toy Genetic Algorithm Model

This notebook is where we will write all the code for our Toy Genetic Algorithm model. This model is simple and can only be trained to perform basic regression tasks, but will give you a good understanding of the essentials of neuroevolution and genetic algorithms.

The architecture for our project is as follows:
- Agent class
  - Defined by a base abstract Agent class.
  - You will create individual agents that inherit from this class.
  - The model/organism/subject or "Agent" that will make up our various populations for the algorithm.
  - It has methods to evaluate itself (the fitness function), mutate it's genome for variation, and a static crossover function for combining multiple genomes of a variable number of agents.
- Genetic Algorithm Class
  - A class that orchestrates the three steps of a genetic algorithm generation 1. Populate, 2. Evaluate, 3. Crossover
  - It can take in any Agent that inherits from the Abstract Agent class.
  - Only performs one "generation".
- Main Program
  - Utilizes the Genetic Algorithm and defined Agents to run many generations with specific sized populations and uses data to test the trained agents.

## BUT BEFORE ANYTHING ELSE MAKE A COPY OF THIS NOTEBOOK OR ELSE YOU WILL LOSE YOUR CODE ONCE YOU SAVE
File > Save a Copy in Drive

## Agents

Run this cell to import nessecary libraries and dependencies, these are mainly just for typing, nothing important to actual model.
"""

from abc import ABC, abstractmethod
from typing_extensions import Self
from typing import Callable, List
import copy

"""### Agent Abstract Class
This will the the base class for an "agent" of our genetic algorithm. Just as we have discussed, an "Agent" should be capable of being evaluate with a "fiteness", or in this case, "challenge" function. It should also be able to mutate its genome given a specific rate between 0.0 - 1.0 inclusive.
"""

class Agent(ABC):
  @abstractmethod
  def __init__(self, mutation_rate: float):
    pass

  @abstractmethod
  def challenge(self, *args, **kwargs) -> float:
      pass

  @abstractmethod
  def mutate(self) -> Self:
      pass

  @staticmethod
  @abstractmethod
  def crossover(agents: List) -> Self:
    pass

"""Now we will create a child class that inherts and implements from this abstract parent Agent class. This specific Agent is meant to perform regression on some function in the XY coordinate space. (e.g. classifying all points above the line y=2x as 1 and all point below or on the line as 0)"""

import torch
from torch import nn
from random import gauss, random

class XYAgent(Agent):

  def __init__(self, rate: float):
    """
    TODO: Define the brain to be torch nn (imported for you) that takes in two inputs (x, y) coords
    and gives 1 output (0 or 1). The hidden layer archictecture is up to you.  Also define the mutation rate given
    the rate parameter given (very simple).
    """
    # YOUR CODE ON THESE TWO LINES
    self.brain = nn.Sequential(
        # nn.Linear(2, 128),
        # nn.ReLU(),
        # nn.Linear(128, 64),
        # nn.ReLU(),
        # nn.Linear(64, 1),
        # nn.Sigmoid(),
        nn.Linear(2, 8),
        nn.ReLU(),
        nn.Linear(8, 1),
        nn.Sigmoid()
    )
    self.rate = rate # mutation rate

  # ---------------------------------------------------- WEEK 2 WORK -------------------------------------------------------- #

  def mutate(self):
    """
    Get the genome for your agent using the function you wrote, then iterate through it and apply some random noise to
    the values in the genome at the defined mutation rate.

    Best method: use a random number between 0 and 1 inclusive and if that number is less than your rate then add a random gaussian number,
    maybe gauss(0, 0.5), although this is entirely up to you.

    Then, we use the set_genome() function we provided which will set the weights in your Agent's brain based on the mutated genome.
    """
    genome = self.get_genome()

    # --------------- YOUR CODE HERE --------------- #
    for i in range(len(genome)):
      if random() < self.rate:
        genome[i] += gauss(0, 0.5)
    # ---------------------------------------------- #

    # Set the mutated genome back to the model
    self.set_genome(genome)

    return self


  def get_genome(self):
    """
    TODO: Collapse all the parameter (weights) of the brain into one long, 1-dimensional torch.tensor and return it.

    E.g [[1,2,3],
         [4,5,6], --> [1,2,3,4,5,6,7,8,9]
         [7,8,9]]

    Think of this like the DNA for your Agent.

    One way you can collect a list of all the weights in the model is:

    weights = [param for name, param in self.brain.named_parameters() if "weight" in name]

    You will need to flatten each of these weights using torch.flatten(WEIGHT),
    then you may simply concatenate all of your flattened weights
    """


    # --------------- YOUR CODE HERE --------------- #
    genome = []
    weights = [param for name, param in self.brain.named_parameters() if "weight" in name]
    for weight in weights:
      genome.append(torch.flatten(weight))
      #genome = torch.cat((genome, torch.flatten(weight)))

    genome = torch.cat(genome)
    # ---------------------------------------------- #

    return genome

  """
  This function takes your collapsed genome and sets the brain weights based on the values
  in the genome. We have taken care of this function for you as it is more of an exercise in
  Pytorch than in the genetic algorithm concepts.
  """
  def set_genome(self, genome):
    genome_index = 0
    weights = [param for name, param in self.brain.named_parameters() if "weight" in name]

    for w in weights:
      # Calculate the size of the current weight tensor
      num_params = w.numel()

      # Extract the corresponding section of the genome
      w_flat = genome[genome_index:genome_index + num_params]

      # Reshape and assign the weight tensor
      w.data = w_flat.reshape(w.shape).to(w.device)

      # Update the genome index
      genome_index += num_params


  def challenge(self, xs, ys):
      """
      TODO: Given two corresponding lists of inputs (x, y) coordinate and outputs (0 or 1 classifications) that are correct,
      have the agent's brain predict on all the inputs and determine how many it got correct given the labels,
      return this as a ratio between 0 and 1 (total correct # / total overall #)

      Use torch.tensor(INPUT).float() to convert an input to a torch tensor of type float
      """
      count_correct = 0

      # --------------- YOUR CODE HERE --------------- #
      for x, y in zip(xs, ys):
        input = torch.tensor(x).float()
        output = self.brain(input)
        if output.item() >= 0.5:
          result = 1
        else:
          result = 0
        if result == y:
          count_correct += 1
      # ---------------------------------------------- #

      # Returns total correct classifications of inputs / total number of inputs
      return count_correct / len(xs)


  def crossover(self, agents):
    """
    Given a list of agent(s) that you would like to crossover (combine into one new agent), implement a crossover method
    This can me randomly choosing non-overlapping portions of the genome like in real life, it could be taking an average
    of all the genomes of all the agents, or it could just be taking the best and returning it, so the new agent is just a copy
    of the best before mutation.
    """

    # Just a placeholder, you will return your new agent.
    return agents[0]

"""## The Genetic Algorithm"""

"""
This is our very simple GeneticAlgorithm class manager. It has three functions:
- populate(), which takes in an agent and a population size and fills the population with copys of that agents that are mutated
- evaluate(), which returns the "best" (an integer parameter) best agents from your population after evaluating them using the
  challenge function which you wrote. If your challenge function takes arguments, like our does (xs, ys), then you pass those as a Python list
  in the "challenge_args" parameter. This function returns a list of the specified number of best agents.
- crossover(), very simple, calls a given cross function on a give list of agents and returns the outputted new agent that is then a
  cross of the agents in the list.
"""

class GeneticAlgorithm:
  def __init__(self):
    self.agents = []

  def populate(self, agent, population_size: int):
    self.agents = [copy.deepcopy(agent).mutate() for _ in range(population_size)]

  def evaluate(self, best: int, challenge_args: list = None) -> List[Agent]:
    if not challenge_args:
      scores = [agent.challenge() for agent in self.agents]
    else:
      scores = [agent.challenge(*challenge_args) for agent in self.agents]

    arranged = [x for _, x in sorted(zip(scores, self.agents), key=lambda t: t[0])]
    return arranged[-best:]

  def crossover(self, agents: List[Agent], cross: Callable[[List[Agent]], Agent]) -> Agent:
    crossed = cross(self=self, agents=agents)
    return crossed

"""## The Main Program"""

from sklearn.model_selection import train_test_split
import numpy as np
import matplotlib.pyplot as plt


def main():
  """
  Create a list of (x, y) coordinates (inputs), 40,000 specifically on a 10x10 grid and then assign labels to the y list based on
  the position of those points.
  """
  X = []
  y = []
  for j in range(200):
    for k in range(200):
      x_coord = j / 20
      y_coord = k / 20
      X.append([x_coord, y_coord])

      """
      You need to append to the y list the proper label, you may chose what your model is going to classify

      Example, the code:

      if y_coord > 2 * x_coord:
          y.append(1)
      else:
          y.append(0)

      Creates labels where points above the line y = 2x is a 1 and points on or below the line are labeled 0.
      """
      # --------------- YOUR CODE HERE --------------- #
      if y_coord > 2 * x_coord:
        y.append(1)
      else:
        y.append(0)
      # ---------------------------------------------- #


  # Separate out data into training and testing data
  X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=42)

  """
  Final steps:
  1. Instantiate out GeneticalAlgorithm class
  2. Create an initial agent and then chose a number of generations
  3. Iterate for that number of generations and during them
    a. Populate the current "best_agent"
    b. Get the best agent(s) using the evalute function
    c. Crossover these agent(s) to get a new "best_agent"

  We recommend that you to add some print statements in your loop to see which
    generation your model is on
  """

  ga = GeneticAlgorithm()

  best_agent = XYAgent(0.7)

  # --------------- YOUR CODE HERE --------------- #
  ga.populate(best_agent, 5)
  num_generations = 5
  while num_generations > 0:
    best_agent = ga.crossover(ga.evaluate(1, [X_train, y_train]), XYAgent.crossover)
    print(num_generations)
    num_generations -= 1

  # ---------------------------------------------- #

  """
  After your code block, the best_agent variable should have the best agent after how every many generations
  """

  # THIS CODE WILLL TEST YOUR AGENT, NO NEED TO MODIFY.
  print(best_agent.challenge(X_test, y_test))

  points = np.array([[i / 20, j / 20] for i in range(0, 201, 10) for j in range(0, 201, 10)])

  # Use the best agent to make predictions on these points
  predictions = [best_agent.brain(torch.tensor(point).float()).item() for point in points]
  colors = ['red' if pred >= 0.5 else 'blue' for pred in predictions]

    # Plot the points
  plt.figure(figsize=(8, 8))
  plt.scatter(points[:, 0], points[:, 1], c=colors)
  plt.title('Predictions of the Best Agent')
  plt.xlabel('X')
  plt.ylabel('Y')
  plt.show()

if __name__ == "__main__":
    main()

